{"version":3,"file":"background.js","mappings":"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","sources":["webpack://accessifix-extension/./background/dom/utils.ts","webpack://accessifix-extension/./background/dom/DOMScanner.ts","webpack://accessifix-extension/./background/background.ts"],"sourcesContent":["/**\n * getAllElements - Recursively collects all HTMLElements from root, including Shadow DOM and iframes.\n */\nexport function getAllElements(root: HTMLElement | Document): HTMLElement[] {\n  const elements: HTMLElement[] = [];\n  const walker = document.createTreeWalker(\n    root instanceof Document ? root.body : root,\n    NodeFilter.SHOW_ELEMENT\n  );\n  let node = walker.nextNode();\n  while (node) {\n    if (node instanceof HTMLElement) {\n      elements.push(node);\n      // Traverse shadow roots\n      if ((node as HTMLElement).shadowRoot) {\n        elements.push(\n          ...getAllElements(\n            (node as HTMLElement).shadowRoot as unknown as HTMLElement\n          )\n        );\n      }\n      // Traverse iframes\n      if (node.tagName === 'IFRAME') {\n        try {\n          const iframeDoc = (node as HTMLIFrameElement).contentDocument;\n          if (iframeDoc) {\n            elements.push(...getAllElements(iframeDoc));\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        } catch (e) {\n          /* ignore cross-origin errors */\n        }\n      }\n    }\n    node = walker.nextNode();\n  }\n  return elements;\n}\n","/**\n * DOMScanner\n * ----------\n * Scans the DOM for accessibility issues using rule-based logic.\n * Extensible for future rules and plugins.\n */\n\nexport interface DOMScanOptions {\n  root?: HTMLElement | Document;\n  includeHidden?: boolean;\n  rules?: string[]; // List of rule IDs to apply\n}\n\nexport interface AccessibilityIssue {\n  type: string;\n  message: string;\n  node: HTMLElement;\n  ruleId: string;\n  severity: 'info' | 'warning' | 'error';\n}\n\nimport { getAllElements } from './utils';\n// eslint-disable-next-line no-unused-vars\ntype RuleCheckFn = (el: HTMLElement) => AccessibilityIssue | null;\n\n/**\n * Internal registry for rule check functions\n */\nconst ruleRegistry: Record<string, RuleCheckFn> = {};\n\nexport class DOMScanner {\n  /**\n   * Scan the DOM for accessibility issues\n   * @param options DOMScanOptions\n   * @returns Array of AccessibilityIssue\n   */\n  static scan(options: DOMScanOptions): AccessibilityIssue[] {\n    const root = options.root || document;\n    const issues: AccessibilityIssue[] = [];\n    const rulesToApply = options.rules || Object.keys(ruleRegistry);\n\n    // Traverse all elements, including shadow DOM and iframes\n    const elements = getAllElements(root);\n    for (const el of elements) {\n      // Optionally skip hidden elements\n      if (\n        !options.includeHidden &&\n        el instanceof HTMLElement &&\n        el.offsetParent === null\n      ) {\n        continue;\n      }\n      // Apply each rule\n      for (const ruleId of rulesToApply) {\n        const checkFn = ruleRegistry[ruleId];\n        if (checkFn) {\n          const issue = checkFn(el as HTMLElement);\n          if (issue) issues.push(issue);\n        }\n      }\n    }\n    return issues;\n  }\n\n  /**\n   * Utility to scan Shadow DOM and iframes recursively\n   */\n\n  // Removed the getAllElements function definition as it is now imported from utils.ts\n\n  /**\n   * Observe dynamic DOM changes and re-scan as needed\n   */\n  static observeAndScan(\n    options: DOMScanOptions,\n    // eslint-disable-next-line no-unused-vars\n    callback: (_issues: AccessibilityIssue[]) => void\n  ): MutationObserver {\n    const root = options.root || document;\n    const observer = new MutationObserver(() => {\n      const issues = DOMScanner.scan(options);\n      callback(issues);\n    });\n    observer.observe(root instanceof Document ? root.body : root, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n    });\n    // Initial scan\n    callback(DOMScanner.scan(options));\n    return observer;\n  }\n\n  /**\n   * Placeholder for future plugin/rule registration\n   */\n  static registerRule(ruleId: string, checkFn: RuleCheckFn) {\n    ruleRegistry[ruleId] = checkFn;\n  }\n\n  /**\n   * Built-in accessibility rules\n   */\n  static registerBuiltInRules() {\n    // Keyboard navigation: tabIndex check and skip link presence\n    DOMScanner.registerRule('keyboard-navigation', (el) => {\n      if (\n        el instanceof HTMLElement &&\n        typeof el.tabIndex === 'number' &&\n        el.tabIndex >= 0\n      ) {\n        // Check for skip link\n        if (el.tagName === 'A' && el.getAttribute('href') === '#main') {\n          return null;\n        }\n        // Flag elements with tabIndex but no clear navigation role\n        const role = el.getAttribute('role');\n        if (!role || role === '') {\n          return {\n            type: 'tab-navigation',\n            message: 'Element is focusable but lacks ARIA role',\n            node: el,\n            ruleId: 'keyboard-navigation',\n            severity: 'info',\n          };\n        }\n      }\n      return null;\n    });\n\n    // Focus indicator: check for outline style\n    DOMScanner.registerRule('focus-indicator', (el) => {\n      if (\n        el instanceof HTMLElement &&\n        typeof el.tabIndex === 'number' &&\n        el.tabIndex >= 0\n      ) {\n        // Check both inline and computed style for outline\n        const outline =\n          el.style.outline || window.getComputedStyle(el).outlineStyle;\n        if (outline === 'none' || outline === '') {\n          return {\n            type: 'missing-focus-indicator',\n            message: 'Focusable element lacks visible focus indicator',\n            node: el,\n            ruleId: 'focus-indicator',\n            severity: 'warning',\n          };\n        }\n      }\n      return null;\n    });\n\n    // ARIA landmark detection\n    DOMScanner.registerRule('aria-landmark', (el) => {\n      if (el instanceof HTMLElement) {\n        const role = el.getAttribute('role');\n        const landmarkRoles = [\n          'banner',\n          'navigation',\n          'main',\n          'complementary',\n          'contentinfo',\n          'form',\n        ];\n        if (role && landmarkRoles.includes(role)) {\n          return {\n            type: 'aria-landmark',\n            message: `Element is an ARIA landmark: ${role}`,\n            node: el,\n            ruleId: 'aria-landmark',\n            severity: 'info',\n          };\n        }\n      }\n      return null;\n    });\n\n    // WCAG color contrast (basic, for demo)\n    DOMScanner.registerRule('wcag-contrast', (el) => {\n      // Parse rgb(a) strings to get luminance\n      function getLuminance(rgb: string): number {\n        const m = rgb.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/);\n        if (!m) return 0;\n        const r = parseInt(m[1], 10) / 255;\n        const g = parseInt(m[2], 10) / 255;\n        const b = parseInt(m[3], 10) / 255;\n        // sRGB luminance formula\n        return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n      }\n      if (el instanceof HTMLElement) {\n        // Check both inline and computed style for color and background\n        const color = el.style.color || window.getComputedStyle(el).color;\n        const bg =\n          el.style.backgroundColor ||\n          window.getComputedStyle(el).backgroundColor;\n\n        const lum1 = getLuminance(color);\n        const lum2 = getLuminance(bg);\n        const contrast =\n          (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05);\n        if (contrast < 4.5) {\n          return {\n            type: 'wcag-low-contrast',\n            message: `Text contrast ratio is ${contrast.toFixed(2)} (WCAG AA requires 4.5)`,\n            node: el,\n            ruleId: 'wcag-contrast',\n            severity: 'error',\n          };\n        }\n      }\n      return null;\n    });\n    // Contrast check (very basic, for demo)\n    DOMScanner.registerRule('contrast', (el) => {\n      if (el instanceof HTMLElement) {\n        const color = window.getComputedStyle(el).color;\n        const bg = window.getComputedStyle(el).backgroundColor;\n        // Simple check: if color and bg are the same, flag\n        if (color === bg) {\n          return {\n            type: 'low-contrast',\n            message: 'Text color matches background color',\n            node: el,\n            ruleId: 'contrast',\n            severity: 'error',\n          };\n        }\n      }\n      return null;\n    });\n\n    // Label presence for inputs\n    DOMScanner.registerRule('input-label', (el) => {\n      if (\n        el.tagName === 'INPUT' &&\n        !el.hasAttribute('aria-label') &&\n        !el.hasAttribute('aria-labelledby')\n      ) {\n        // Check for associated <label>\n        const id = el.getAttribute('id');\n        if (id) {\n          const label = document.querySelector(`label[for=\"${id}\"]`);\n          if (label) return null;\n        }\n        return {\n          type: 'missing-label',\n          message: 'Input element missing label or ARIA label',\n          node: el,\n          ruleId: 'input-label',\n          severity: 'warning',\n        };\n      }\n      return null;\n    });\n\n    // ARIA role check\n    DOMScanner.registerRule('aria-role', (el) => {\n      if (el instanceof HTMLElement && el.hasAttribute('role')) {\n        const role = el.getAttribute('role');\n        // Example: flag unknown roles\n        const knownRoles = [\n          'button',\n          'navigation',\n          'main',\n          'form',\n          'dialog',\n          'banner',\n          'contentinfo',\n          'complementary',\n        ];\n        if (role && !knownRoles.includes(role)) {\n          return {\n            type: 'unknown-aria-role',\n            message: `Unknown ARIA role: ${role}`,\n            node: el,\n            ruleId: 'aria-role',\n            severity: 'info',\n          };\n        }\n      }\n      return null;\n    });\n\n    // Form field detection\n    DOMScanner.registerRule('form-field', (el) => {\n      if (el.tagName === 'FORM') {\n        const inputs = el.querySelectorAll('input, select, textarea');\n        if (inputs.length === 0) {\n          return {\n            type: 'empty-form',\n            message: 'Form has no input fields',\n            node: el,\n            ruleId: 'form-field',\n            severity: 'warning',\n          };\n        }\n      }\n      return null;\n    });\n  }\n}\n","// background/background.ts\n// AccessiFix Extension Background Script\n// Handles rule engine coordination and extension events\n\nimport { DOMScanner } from './dom/DOMScanner';\n// Expose DOMScanner globally for browser-based tests (Playwright)\ndeclare global {\n  interface Window {\n    DOMScanner: typeof DOMScanner;\n  }\n}\nif (typeof window !== 'undefined') {\n  window.DOMScanner = DOMScanner;\n}\nexport {};\n"],"names":["getAllElements","root","elements","walker","document","createTreeWalker","Document","body","NodeFilter","SHOW_ELEMENT","node","nextNode","HTMLElement","push","shadowRoot","tagName","iframeDoc","contentDocument","e","ruleRegistry","DOMScanner","scan","options","issues","rulesToApply","rules","Object","keys","el","includeHidden","offsetParent","ruleId","checkFn","issue","observeAndScan","callback","observer","MutationObserver","observe","childList","subtree","attributes","registerRule","registerBuiltInRules","tabIndex","getAttribute","role","type","message","severity","outline","style","window","getComputedStyle","outlineStyle","includes","getLuminance","rgb","m","match","parseInt","color","bg","backgroundColor","lum1","lum2","contrast","Math","max","min","toFixed","hasAttribute","id","querySelector","querySelectorAll","length"],"sourceRoot":""}